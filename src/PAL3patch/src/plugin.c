#include "common.h"


// misc


// patch memory allocator wrapper
// user should use these function when dealing with memory blocks
//   that was allocated in PAL3patch
//    e.g. cs2wcs_alloc() cs2wcs_managed()
void *patch_malloc(size_t size)
{
    return malloc(size);
}
void patch_free(void *ptr)
{
    free(ptr);
}

// compare two version strings, only compare numbers
//   for example:
//     v1.0 == x1.0
//     v1 == v1.0.0
//     v1.0 < v1.0.1
//     v1.2 < v1.10
//     v2.0 > v1.99
int version_string_compare(const char *a, const char *b)
{
    unsigned na, nb;
    do {
        while (*a && !('0' <= *a && *a <= '9')) a++;
        for (na = 0; '0' <= *a && *a <= '9'; a++) na = na * 10 + (*a - '0');
        while (*b && !('0' <= *b && *b <= '9')) b++;
        for (nb = 0; '0' <= *b && *b <= '9'; b++) nb = nb * 10 + (*b - '0');
    } while (na == nb && (*a || *b));
    if (na < nb) return -1;
    if (na > nb) return 1;
    return 0;
}


// plugin log system

int plugin_log_indent = 0;

static void make_plugin_log_header()
{
    static int flag = 0;
    if (flag) return;
    flag = 1;
    
    FILE *fp = fopen(PLUGIN_LOG_FILE, "w");
    if (fp) {
        fputs(UTF8_BOM_STR, fp);
        fprintf(fp, "; PAL3patch Plugin Host Log File\n");
        fprintf(fp, "; generated by PAL3patch %s (built on %s)\n", patch_version, build_date);
    	fprintf(fp, "\n");
    	fprintf(fp, "%-23s | %-15s | %s\n", "; timestamp", "module", "message");
    	fprintf(fp, "\n");
        fclose(fp);
    }
}

static void write_plugin_log(const char *module, int indent, const char *message)
{
    make_plugin_log_header();
    
    int real_indent = (indent % MAX_PLUGIN_LOG_INDENT + MAX_PLUGIN_LOG_INDENT) % MAX_PLUGIN_LOG_INDENT;
    int i;
    
    FILE *fp = fopen(PLUGIN_LOG_FILE, "a");
    if (fp) {
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        const char *curline = message;
        while (1) {
            fprintf(fp, "%04hu-%02hu-%02hu %02hu:%02hu:%02hu.%03hu | %-15s | ", SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds, module ? module : "UNKNOWN");
            for (i = 1; i <= real_indent; i++) fputs("  ", fp);
            const char *nextline = strchr(curline, '\n');
            if (nextline) {
                fprintf(fp, "%.*s", nextline + 1 - curline, curline);
                curline = nextline + 1;
                if (!*curline) break;
            } else {
                fputs(curline, fp);
                fputc('\n', fp);
                break;
            }
        }
        
        fclose(fp);
    }
}

static wchar_t *msgbox_buf = NULL;
#define free_msgbox_buf() do { free(msgbox_buf); msgbox_buf = NULL; } while (0)

void plugin_plog(const char *module, int indent, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, indent, msgbuf);
    va_end(ap);
}

static int plugin_warning_msgboxes = 0;
void plugin_warning(const char *module, int indent, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, indent, msgbuf);    
    if (plugin_warning_msgboxes + 1 <= MAXWARNMSGBOXES) {
        plugin_warning_msgboxes++;
        if (plugin_warning_msgboxes >= MAXWARNMSGBOXES) {
            strncat(msgbuf, "\n\nmax messagebox limit reached, suppressing further messageboxes.", sizeof(msgbuf) - strlen(msgbuf) - 1);
            msgbuf[sizeof(msgbuf) - 1] = '\0';
        }
        try_goto_desktop();
        MessageBoxW(NULL, cs2wcs_managed(msgbuf, CP_UTF8, &msgbox_buf), L"PAL3patch Plugin Host", MB_ICONWARNING | MB_TOPMOST | MB_SETFOREGROUND);
    }
    free_msgbox_buf();
    va_end(ap);
}

void plugin_fail(const char *module, int indent, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, indent, msgbuf);
    try_goto_desktop();
    MessageBoxW(NULL, cs2wcs_managed(msgbuf, CP_UTF8, &msgbox_buf), L"PAL3patch Plugin Host", MB_ICONERROR | MB_TOPMOST | MB_SETFOREGROUND);
    free_msgbox_buf();
    die(2);
    va_end(ap);
}






// plugin loader



#define pplog(fmt, ...) plugin_plog("PAL3PATCH", plugin_log_indent, fmt, ##__VA_ARGS__)
#define pplog_enter() (++plugin_log_indent)
#define pplog_leave() (--plugin_log_indent)

struct plugin_desc {
    struct plugin_desc *next;
    
    HMODULE handle;
    int mode;
    int type;
    
    // may be NULL if plain DLL
    DECL_PLUGINENTRY(*entry);
    const char *internal_name;
    const wchar_t *friendly_name;
    const char *version;
    const char *platform;
    const char *builton;
    const char *compiler;
};

static int total_plugins = 0;
static struct plugin_desc *plugin_list_head = NULL;

static struct wstr plugin_report_body;

// check if plugin already loaded, O(n)
static int check_register_plugin(struct plugin_desc *newplugin)
{
    struct plugin_desc *ptr;
    for (ptr = plugin_list_head; ptr; ptr = ptr->next) {
        if (ptr->handle == newplugin->handle) {
            return 0;
        }
    }
    return 1;
}

static void commit_register_plugin(struct plugin_desc *newplugin)
{
    newplugin->next = plugin_list_head;
    plugin_list_head = newplugin;
    if (newplugin->type == 0) {
        total_plugins++;
    }
}

static void load_plugin_dll_with_mode(const char *filename, int mode, int type)
{
    // mode == 0: normal LoadLibrary
    // mode != 0: call LoadLibraryEx with parameter LOAD_WITH_ALTERED_SEARCH_PATH
    
    // type == 0: LoadLibary and call plugin entry (plugin DLL)
    // type != 0: call LoadLibrary only (plain DLL)
    
    DWORD dwFlags;
    wchar_t *wfilename_managed = NULL;
    char *u8name_managed = NULL;
    struct plugin_desc *newplugin = NULL;
    HMODULE hModule = NULL;
    DECL_PLUGINENTRY(*entry);
    int r;
    int success = 0;
    struct wstr errmsg, line, namepart;
    wstr_ctor(&errmsg);
    wstr_ctor(&line);
    wstr_ctor(&namepart);
    
    dwFlags = mode ? LOAD_WITH_ALTERED_SEARCH_PATH : 0;
    
    newplugin = malloc(sizeof(struct plugin_desc));
    memset(newplugin, 0, sizeof(struct plugin_desc));
    newplugin->mode = mode;
    newplugin->type = type;
    
    cs2wcs_managed(filename, CP_UTF8, &wfilename_managed);
    newplugin->handle = hModule = LoadLibraryExW(wfilename_managed, NULL, dwFlags);
    if (!hModule) {
        pplog("error: LoadLibraryEx() failed.");
        try_goto_desktop();
        wstr_wcscpy(&errmsg, wstr_pluginerr_loadfailed);
        goto fail;
    }

    if (!check_register_plugin(newplugin)) {
        pplog("dll already loaded.");
        goto skip;
    }
    
    if (type == 0) { // is plugin DLL
        newplugin->entry = entry = TOPTR(GetProcAddress(hModule, TOSTR(PLUGINSYMBOL_ENTRY)));
        
        if (!entry) {
            pplog("error: GetProcAddress() failed.");
            try_goto_desktop();
            wstr_wcscpy(&errmsg, wstr_pluginerr_noentry);
            goto fail;
        }

        newplugin->internal_name = TOPTR(GetProcAddress(hModule, TOSTR(PLUGINSYMBOL_INTERNAL_NAME)));
        newplugin->friendly_name = TOPTR(GetProcAddress(hModule, TOSTR(PLUGINSYMBOL_FRIENDLY_NAME)));
        newplugin->version       = TOPTR(GetProcAddress(hModule, TOSTR(PLUGINSYMBOL_VERSION)));
        newplugin->platform      = TOPTR(GetProcAddress(hModule, TOSTR(PLUGINSYMBOL_PLATFORM)));
        newplugin->builton       = TOPTR(GetProcAddress(hModule, TOSTR(PLUGINSYMBOL_BUILTON)));
        newplugin->compiler      = TOPTR(GetProcAddress(hModule, TOSTR(PLUGINSYMBOL_COMPILER)));
        if (newplugin->friendly_name) {
            wcs2cs_managed(newplugin->friendly_name, CP_UTF8, &u8name_managed);
        }
        
        pplog("plugin entry         : %08X (base %08X)\n", TOUINT(entry) - TOUINT(hModule), TOUINT(hModule));
        if (newplugin->internal_name) pplog("plugin internal-name : %s", newplugin->internal_name);
        if (u8name_managed)           pplog("plugin friendly-name : %s", u8name_managed);
        if (newplugin->version)  pplog("plugin version       : %s", newplugin->version);
        if (newplugin->platform) pplog("plugin platform      : %s", newplugin->platform);
        if (newplugin->builton)  pplog("plugin built on      : %s", newplugin->builton);
        if (newplugin->compiler) pplog("plugin compiler      : %s", newplugin->compiler);

        pplog("executing plugin initialization procedure ...");
        pplog_enter();
        r = entry();
        pplog_leave();
        if (r != 0) {
            pplog("error: initialization procedure returns %d.", r);
            try_goto_desktop();
            wstr_format(&errmsg, wstr_pluginerr_initfailed, r);
            goto initfail;
        }
    }
    
    commit_register_plugin(newplugin);
    pplog("dll loaded successfully.");
    success = 1;
    
done:
    
    if (type == 0) {
        if (success && newplugin->friendly_name) {
            wstr_format(&namepart, wstr_pluginreport_namepart, newplugin->friendly_name, newplugin->version ? newplugin->version : "", get_wfilepart(wfilename_managed));
        } else {
            wstr_wcscpy(&namepart, get_wfilepart(wfilename_managed));
        }
        if (success) {
            wstr_format(&line, wstr_pluginreport_success, wstr_getwcs(&namepart));
        } else {
            wstr_format(&line, wstr_pluginreport_failed, wstr_getwcs(&namepart), wstr_getwcs(&errmsg));
        }
        wstr_wcscat(&plugin_report_body, wstr_getwcs(&line));
    }
    
    if (success) newplugin = NULL;
    free(newplugin);
    free(wfilename_managed);
    free(u8name_managed);
    wstr_dtor(&errmsg);
    wstr_dtor(&line);
    wstr_dtor(&namepart);
    return;
fail:
skip:
    if (hModule) FreeLibrary(hModule);
initfail:
    goto done;
}

void load_plugin_dll(const char *filename)
{
    pplog("loading plugin dll '%s' ...", filename);
    pplog_enter();
    load_plugin_dll_with_mode(filename, 0, 0);
    pplog_leave();
}
void load_plugin_dll_and_dependents(const char *filename)
{
    pplog("loading plugin dll '%s' and its dependents ...", filename);
    pplog_enter();
    load_plugin_dll_with_mode(filename, 1, 0);
    pplog_leave();
}
void load_plugin_library(const char *filename)
{
    pplog("loading dll library '%s' ...", filename);
    pplog_enter();
    load_plugin_dll_with_mode(filename, 0, 1);
    pplog_leave();
}
void load_plugin_library_and_dependents(const char *filename)
{
    pplog("loading dll library '%s' and its dependents ...", filename);
    pplog_enter();
    load_plugin_dll_with_mode(filename, 1, 1);
    pplog_leave();
}

void load_plugin_list(const char *filename)
{
    char *filestr = NULL;
    char *cstr_managed = NULL;
    wchar_t *wstr_managed = NULL;
    wchar_t wbuf[MAXLINE];
    wchar_t fullpath[MAXLINE];
    wchar_t *fullpath_filepart;
    char *line;
    const char *line_delim = "\r\n";
    char *line_saveptr;
    char *directive, *parameter;
    char *token_saveptr;
    
    pplog("executing plugin file '%s' ...", filename);
    pplog_enter();
    
    // convert utf8 filename to unicode full path name
    if (!utf8_filepath_to_wstr_fullpath(filename, fullpath, MAXLINE, &fullpath_filepart)) goto fail;
    if (!fullpath_filepart) goto fail;
    
    // read whole file as a string
    filestr = read_file_as_cstring(wcs2cs_managed(fullpath, CP_UTF8, &cstr_managed));
    if (!filestr) goto fail;
    str_remove_utf8_bom(filestr);
    
    // parse the file
    for (line = strtok_r(filestr, line_delim, &line_saveptr); line; line = strtok_r(NULL, line_delim, &line_saveptr)) {

        directive = strtok_r(line, SPACECHAR_LIST, &token_saveptr);
        if (!directive || *directive == '#' || *directive == ';' || (directive[0] == '/' && directive[1] == '/')) continue;
        
        if (stricmp(directive, "END") == 0 || stricmp(directive, "EXIT") == 0 || stricmp(directive, "QUIT") == 0) {
            break;
        }
        
        parameter = strtok_r(NULL, line_delim, &token_saveptr); // use line_delim to fetch the whole remaining string
        if (!parameter) {
            pplog("error: no parameter directive '%s'.", directive);
            goto fail;
        }
        str_trim(parameter, SPACECHAR_LIST);
        
        // resolve relative path if needed
        if (is_relpath(parameter)) {

            // resolve relative path
            cs2wcs_managed(parameter, CP_UTF8, &wstr_managed);
            if (!replace_filepart_with_relpath(fullpath, wstr_managed, wbuf, MAXLINE, NULL)) goto fail;
            
            // convert buffer to utf8 string
            wcs2cs_managed(wbuf, CP_UTF8, &cstr_managed);
            parameter = cstr_managed;
            
        }

        if (stricmp(directive, "DLL") == 0 || stricmp(directive, "LOAD_DLL") == 0) {
            load_plugin_dll(parameter);
        } else if (stricmp(directive, "DLL2") == 0 || stricmp(directive, "LOAD_DLL_AND_DEPENDENTS") == 0) {
            load_plugin_dll_and_dependents(parameter);
        } else if (stricmp(directive, "LIB") == 0 || stricmp(directive, "LOAD_LIBRARY") == 0) {
            load_plugin_library(parameter);
        } else if (stricmp(directive, "LIB2") == 0 || stricmp(directive, "LOAD_LIBRARY_AND_DEPENDENTS") == 0) {
            load_plugin_library_and_dependents(parameter);
        } else if (stricmp(directive, "LIST") == 0 || stricmp(directive, "LOAD_PLUGIN") == 0) {
            load_plugin_list(parameter);
        } else if (stricmp(directive, "DIR") == 0 || stricmp(directive, "SEARCH_DIR") == 0) {
            search_plugins(parameter);
        } else {
            pplog("error: unknown directive '%s'.", directive);
            goto fail;
        }
    }
    
done:
    free(filestr);
    free(cstr_managed);
    free(wstr_managed);
    pplog("execution finished.");
    pplog_leave();
    return;
fail:
    pplog("error occurred while executing plugin file.");
    goto done;
}



static void enum_plugin_files_funchelper(const char *filename, void *arg)
{
    ((void (*)(const char *)) arg)(filename);
}
static void enum_plugin_files(const char *dirpath, const char *pattern, void (*func)(const char *filepath))
{
    int r = enum_files(dirpath, pattern, enum_plugin_files_funchelper, func);
    if (r == 0) {
        pplog("no file found in directory '%s' with pattern '%s'.", dirpath, pattern);
    } else if (r < 0) {
        pplog("error occurred while enumerating files.");
    }
}

void search_plugins(const char *dirpath)
{
    pplog("searching plugins in directory '%s' ...", dirpath);
    pplog_enter();
    enum_plugin_files(dirpath, "*.plugin", load_plugin_list);
    enum_plugin_files(dirpath, "*.dll", load_plugin_dll);
    pplog("search finished.");
    pplog_leave();
}

void init_plugins()
{
    int flag = get_int_from_configfile("loadplugins");
    if (flag) {
        wstr_ctor(&plugin_report_body);
        
        search_plugins("plugins");
        pplog("total %d plugin%s loaded at game startup time.", total_plugins, total_plugins > 1 ? "s" : "");

        if (wstr_at(&plugin_report_body, 0)) {
            struct wstr report;
            wstr_ctor(&report);
            wstr_format(&report, wstr_pluginreport_template, wstr_getwcs(&plugin_report_body), total_plugins);
            MessageBoxW(NULL, wstr_getwcs(&report), wstr_pluginreport_title,  MB_ICONINFORMATION | MB_TOPMOST | MB_SETFOREGROUND);
            wstr_dtor(&report);
        }
        // do not destruct plugin_report here, because plugins may load other plugins after initialization
    }
}
